<?php
/**
 * @file
 * Provides custom integration with the Eventbrite API.
 */

define('EVENTBRITE_INTEGRATION_MAPPING_PREFIX', 'eventbrite_field_mapping_');

/**
 * Load the Eventbrite API object.
 *
 * @return mixed
 *   Either NULL if the load fails, or an Eventbrite object.
 */
function eventbrite_integration_get_eventbrite_api() {
  $library = libraries_load('eventbrite');
  $eventbrite_api = new Eventbrite(array(
    'app_key' => variable_get('eventbrite_app_key', ''),
    'user_key' => variable_get('eventbrite_user_key', ''),
  ));
  if (empty($library['loaded']) || empty($eventbrite_api)) {
    drupal_set_message(t('Unable to load Eventbrite API library.', 'error'));
    return NULL;
  }
  return $eventbrite_api;
}

/**
 * Implements hook_cron().
 */
function eventbrite_integration_cron() {
  eventbrite_integration_update_all_attendees();
}

/**
 * Implements hook_cron_queue_info().
 */
function eventbrite_integration_cron_queue_info() {
  $queues = array();

  $queues['eventbrite_integration_bios_queue'] = array(
    'worker callback' => 'eventbrite_integration_update_attendee',
    'time' => 30,
  );

  return $queues;
}

/**
 * Updates all attendees with the latest Eventbrite data.
 */
function eventbrite_integration_update_all_attendees() {
  // Load the queue.
  $queue = DrupalQueue::get('eventbrite_integration_bios_queue');
  // Load the Eventbrite API.
  $eventbrite_api = eventbrite_integration_get_eventbrite_api();
  if (empty($eventbrite_api)) {
    return;
  }
  // Load all existing IDs.
  $bios = eventbrite_integration_get_bios();
  // Get a list of all events.
  $events = eventbrite_integration_get_events();
  // Get the attendees from Eventbrite for each event.
  foreach ($events as $event) {
    // Less performant, but there should never be more than one or two of these,
    // so it's not worth the hassle of using field_attach_load() and so on.
    $event = node_load($event->nid);
    $event_ids = field_get_items('node', $event, 'field_even_eventbrite');
    $eventbrite_id = $event_ids[0]['value'];
    $attendees_list = $eventbrite_api->__call('event_list_attendees', array(array(
      'id' => $eventbrite_id
    )));
    // Loop through the list of attendees from the Eventbrite API.
    foreach($attendees_list->attendees as $attendee) {
      $id = $attendee->attendee->id;
      // The node already exists, so use that.
      if (array_key_exists($id, $bios)) {
        $bio = $bios[$id];
      }
      // The node doesn't exist yet.
      else {
        $bio = array();
      }
      // Attach the event NID.
      $bio['event_nid'] = $event->nid;
      // Attach the attendee.
      $bio['attendee'] = $attendee;
      // Send the bio into the queue.
      $queue->createItem($bio);
    }
  }
}

/**
 * Worker callback for hook_cron_queue_info().
 *
 * Updates an individual attendee node.
 *
 * @see eventbrite_integration_cron_queue_info()
 */
function eventbrite_integration_update_attendee($data) {
  // Get the attendee, for easier access.
  $attendee = $data['attendee']->attendee;
  // Load the current node if it exists.
  if (!empty($data['nid'])) {
    $node = node_load($data['nid']);
    if (empty($node)) {
      return;
    }
  }
  // Create a new node if it doesn't.
  else {
    $node = new stdClass();
    $node->type = 'bio';
    $node->language = LANGUAGE_NONE;
    node_object_prepare($node);
  }

  // Get the list of field mappings.
  $mappings = variable_get(EVENTBRITE_INTEGRATION_MAPPING_PREFIX . $data['event_nid'], array());

  // Create an EMW, to be used for setting the data.
  $wrapper = entity_metadata_wrapper('node', $node);

  // Load the V3 Eventbrite API.
  static $api;
  if (empty($api)) {
    $api = new EventbriteV3();
  }
  $ticket = $api->get_ticket($attendee->event_id, $attendee->ticket_id);

  $wrapper->field_bio_eventbrite = $attendee->id;
  $wrapper->field_bio_eb_order_no = $attendee->order_id;
  $wrapper->field_bio_eb_ticket_type = $ticket->name;
  $wrapper->field_bio_eb_order_type = $attendee->order_type;
  $wrapper->field_bio_total_paid = $attendee->amount_paid;
  $wrapper->field_bio_eb_event_id = $attendee->event_id;

  foreach ($mappings as $eventbrite_field_id => $drupal_field_id) {
    if (empty($drupal_field_id)) {
      // This Eventbrite field has no Drupal mapping, so skip it.
      continue;
    }
    // Check to see if the field is a core Eventbrite question.
    if (property_exists($attendee, $eventbrite_field_id)) {
      $eventbrite_data = $attendee->$eventbrite_field_id;
    }
    // This is a custom question.
    else {
      foreach ($attendee->answers as $answer) {
        $answer = $answer->answer;
        if ($answer->question_id == $eventbrite_field_id) {
          $eventbrite_data = $answer->answer_text;
        }
      }
    }

    // Somehow this isn't set yet, so skip it since there's no data to set.
    if (!isset($eventbrite_data)) {
      continue;
    }

    // Field info and field instance info are needed to deal with special cases.
    $field = field_info_field($drupal_field_id);
    $field_instance = field_info_instance('node', $drupal_field_id, 'bio');

    // EMW will throw exceptions if the data doesn't validate. Rather than allow
    // that to interrupt the flow, the field should be skipped by ignoring the
    // exception and moving on.
    try {
      // Deal with link fields.
      if ($field['type'] == 'link_field') {
        if (empty($eventbrite_data)) {
          $eventbrite_data = '';
        }
        $wrapper->$drupal_field_id->url = $eventbrite_data;
        // Set the title if it's anything other than not allowed.
        if ($field_instance['settings']['title'] != "none") {
          $wrapper->$drupal_field_id->title = $eventbrite_data;
        }
      }
      // Deal with long text fields.
      elseif ($field['type'] == 'text_with_summary') {
        $wrapper->$drupal_field_id->safe_value = $eventbrite_data;
        $wrapper->$drupal_field_id->value = $eventbrite_data;
      }
      elseif ($field['type'] == 'list_text') {
        $allowed_values = $field['settings']['allowed_values'];
        $wrapper->$drupal_field_id = array_search($eventbrite_data, $allowed_values);
      }
      // Everything else can be set normally.
      else {
        $wrapper->$drupal_field_id = $eventbrite_data;
      }
    }
    // Log the exception, at least.
    catch (Exception $e) {
      watchdog('eventbrite_integration', $e->getMessage());
    }
  }

  // Save the wrapper.
  $wrapper->save();
  // Save the node.
  node_save($node);
  // Re-load the node. This is unfortunate but necessary, or node titles will
  // not set properly.
  $node = node_load($node->nid);
  // Build the node title automatically.
  auto_entitylabel_set_title($node, 'node');
  // Save again, to save the new title.
  node_save($node);
}

/**
 * Loads all events.
 *
 * @return array
 *   An empty array, or an array of all events, as returned from EFQ.
 */
function eventbrite_integration_get_events() {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'even');
  $result = $query->execute();
  if (!empty($result['node'])) {
    return $result['node'];
  }
  else {
    return array();
  }
}

/**
 * Returns the Eventbrite IDs for all Bio nodes.
 *
 * @return array
 *   Either an empty array, or an array of NIDs and Eventbrite IDs, keyed by
 *   Eventbrite ID.
 */
function eventbrite_integration_get_bios() {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'bio')
    ->fieldCondition('field_bio_eventbrite', 'value', 'NULL', '!=');
  $result = $query->execute();
  if (!empty($result['node'])) {
    $ids = array();
    // Attach the Eventbrite ID field to the objects.
    $fields = field_info_instances('node', 'bio');
    field_attach_load('node', $result['node'], FIELD_LOAD_CURRENT, array('field_id' => $fields['field_bio_eventbrite']['field_id']));
    // Extract the IDs and return them.
    foreach ($result['node'] as $bio) {
      $eventbrite_ids = field_get_items('node', $bio, 'field_bio_eventbrite');
      $id = $eventbrite_ids[0]['value'];
      $ids[$id] = array(
        'nid' => $bio->nid,
        'field_bio_eventbrite' => $id,
      );
    }
    return $ids;
  }
  else {
    return array();
  }
}

/**
 * Custom link validator.
 *
 * @param string $text
 *   The link text to be checked.
 *
 * @return mixed
 *   Either boolean FALSE, or the LINK_EXTERNAL constant.
 *
 * @see link_validate_url()
 */
function eventbrite_integration_validate_url($text = '') {
  $link = link_validate_url($text);
  // External links should have a period in them somewhere - http://example.com,
  // for instance. This is to prevent links like @Example_Com from passing
  // link_validate_url(), which they do and shouldn't.
  if ($link == LINK_EXTERNAL && strpos($text, '.')) {
    return LINK_EXTERNAL;
  }
  else {
    return FALSE;
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function eventbrite_integration_form_eventbrite_admin_settings_alter(&$form, &$form_state) {
  $form['eventbrite_oauth_token'] = array(
    '#type' => 'textfield',
    '#title' => t('OAuth key'),
    '#required' => TRUE,
    '#default_value' => variable_get('eventbrite_oauth_token', ''),
    '#description' => t("Your app's OAuth key. It can be found !here. You will need to create an app if you haven't already.", array('!here' => l('here', 'https://www.eventbrite.com/myaccount/apps/'))),
  );
}

/**
 * Implements hook_menu().
 */
function eventbrite_integration_menu() {
  $items = array();

  $items['admin/config/services/eventbrite/bio-field-mapping'] = array(
    'type' => MENU_LOCAL_TASK,
    'title' => 'Bio field mapping',
    'description' => 'Configure mapping between Eventbrite fields and Bio fields.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('eventbrite_integration_bio_field_mapping'),
    'weight' => 10,
    'access arguments' => array('administer site configuration'),
  );

  return $items;
}

/**
 * Form builder callback.
 *
 * Builds a form for mapping between Eventbrite fields and Bio fields.
 */
function eventbrite_integration_bio_field_mapping($form, &$form_state) {
  $form['help_text'] = array(
    '#markup' =>
      "<p>" . t("Create mappings between Eventbrite order form fields and Bio fields.") . "</p>" .
      "<p>" . t("Each select field is a field on the event's Eventbrite order form, and the options in the field are fields on the Bio content type.") . "</p>",
  );

  // Load the V3 Eventbrite API.
  $api = new EventbriteV3();

  // Default profile questions.
  $default_questions = array(
    'first_name' => 'First Name',
    'last_name' => 'Last Name',
    'email' => 'Email Address',
    'cell_phone' => 'Cell Phone',
    'job_title' => 'Job Title',
    'company' => 'Company / Organization',
    'website' => 'Website',
  );

  // Build a list of all Bio fields, for a select list.
  $fields_info = field_info_instances('node', 'bio');
  $field_options = array(
    '' => t('- Select -'),
  );
  foreach ($fields_info as $name => $field_info) {
    $field_options[$name] = $field_info['label'];
  }

  // Get a list of all events.
  $events = eventbrite_integration_get_events();
  if (empty($events)) {
    drupal_set_message(t('Unable to load any events.'), 'error');
    return $form;
  }

  // For each event, build a fieldset of fields to map.
  foreach ($events as $event) {
    // Start with the default questions.
    $event_questions = $default_questions;
    $event = node_load($event->nid);
    // Store the NID for convenience, since it will be re-used often.
    $nid = $event->nid;
    $event_id = field_get_items('node', $event, 'field_even_eventbrite');
    if (!empty($event_id[0]['value'])) {
      $eventbrite_id = $event_id[0]['value'];
    }
    else {
      // Skip the event if it doesn't have an Eventbrite ID.
      continue;
    }

    // Load custom Eventbrite questions.
    $questions = $api->get_event_questions($eventbrite_id);
    foreach ($questions->questions as $question) {
      $question_id = $question->id;
      $question_text = $question->question->text;
      $event_questions[$question_id] = $question_text;
    }

    // Build the fieldset for the event.
    $event_fieldset_id = EVENTBRITE_INTEGRATION_MAPPING_PREFIX . $nid;
    $form[$event_fieldset_id] = array(
      '#type' => 'fieldset',
      '#title' => $event->title,
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#tree' => TRUE,
    );
    // Store the fieldset as a reference for convenience.
    $fieldset = &$form[$event_fieldset_id];
    // Create each Eventbrite field as a select list. The options are the fields
    //from the Bio content type.
    $default_form_values = variable_get($event_fieldset_id, array());
    foreach ($event_questions as $question_id => $question_label) {
      $fieldset[$question_id] = array(
        '#type' => 'select',
        '#options' => $field_options,
        '#title' => $question_label,
        '#default_value' => array_key_exists($question_id, $default_form_values) ? $default_form_values[$question_id] : '',
      );
    }
  }

  $form = system_settings_form($form);
  // Remove the system_settings_form_submit() submit handler.
  $form['#submit'] = array(
    'eventbrite_integration_bio_field_mapping_submit',
  );
  return $form;
}

/**
 * Form submission handler.
 *
 * @see eventbrite_integration_bio_field_mapping()
 */
function eventbrite_integration_bio_field_mapping_submit($form, &$form_state) {
  // Get a list of all events.
  $events = eventbrite_integration_get_events();
  // Easy access to the values.
  $values = $form_state['values'];
  foreach ($events as $event) {
    // Store the form values per event as an array.
    $field_id = EVENTBRITE_INTEGRATION_MAPPING_PREFIX . $event->nid;
    if (!empty($values[$field_id])) {
      variable_set($field_id, $values[$field_id]);
    }
  }
}
